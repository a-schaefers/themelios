#!/usr/bin/env bash
# MIT License

# Copyright 2018 Adam Schaefers sch@efers.org

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

usage() {
    cat << EOF
Usage:
        themelios configuration.sh git-remote [branch]

Use -h or --help for more information.
EOF
    exit
}

help() {
    cat <<EOF
Usage:
        themelios configuration.sh git-remote [branch]

For detailed examples and instructions please visit the github page:

    https://github.com/a-schaefers/themelios

Essentially, feed Themelios a git repository url that contains a file which has the following configuration variables:

# Themelios configuration.sh example
POOL_NAME="zroot"
POOL_TYPE=""          # May also be set to "mirror" or "raidz1", etc... Leave empty "" for single.

# use one disk per line here!
# POOL_DISKS="/dev/sda
# /dev/sdb
# /dev/sdc"
POOL_DISKS="/dev/sda"

SGDISK_CLEAR="true"   # Use sgdisk --clear
WIPEFS_ALL="true"     # Use wipefs --all
ZERO_DISKS="false"    # Use dd if=/dev/zero ...
ATIME="off"           # Set to "on" or "off" (recommended "off" for SSD.)
SNAPSHOT_ROOT="true"  # Set the value of com.sun:auto-snapshot
SNAPSHOT_HOME="true"
USE_ZSWAP="false"     # Creates a swap zvol
ZSWAP_SIZE="4G"

# Your top-level configuration.nix file to be bootstrapped-- (use the relative path from the project_root.)
# For example, to bootstrap project_root/hosts/vm-example/default.nix all of the following are equivalent:
TOP_LEVEL_NIXFILE="./hosts/vm-example"
TOP_LEVEL_NIXFILE="hosts/vm-example"
TOP_LEVEL_NIXFILE="hosts/vm-example/default.nix"

# Directory name of to clone your git-remote in "/" (root). # May be anything, but do not use slashes.
# This is intended to be the directory to operate the nix installation from.
NIXCFG_DIR="nix-config"

# If true, mount /nix outside of the / (root) dataset.
# Setting this to true would trade-off the ability to use zfs boot environments for extra disk space.
# If you use nix.gc.automatic, then this should not be much of an issue. Recommended "false".
NIXDIR_NOROOT="false" # mount /nix outside of the / (root) dataset.

# Creates /etc/nixos/themelios-zfs.nix with sensible settings
THEMELIOS_ZFS="true"

# Enable ZFS_CARE Options? (Only enable this if THEMELIOS_ZFS="true" also.)
THEMELIOS_ZFS_CARE="true"

####################
# ZFS_CARE Options #
####################

# Auto Scrubs
care_autoScrub="true"

# Auto Snapshots
care_autoSnapshot_enabled="true"
care_autoSnapshot_frequent="8"   # Take a snapshot every 15 minutes and keep 8 in rotation
care_autoSnapshot_hourly="0"
care_autoSnapshot_daily="7"      # Take a daily snapshot and keep 7 in rotation
care_autoSnapshot_weekly="0"
care_autoSnapshot_monthly="0"

# Auto Garbage Collection
care_gc_automatic="true"
care_gc_dates="daily"
care_gc_options="--delete-older-than 7d"

# Auto /tmp clean
care_cleanTmpDir="true"

####################
# Overlay Section #
####################

# If set, Themelios will source them if the files exist alongside configuration.sh
POOL_OVERLAY_FILE="overlay-pool"         # Override __zpool_create()
DATASETS_OVERLAY_FILE="overlay-datasets" # Override __datasets_create()
EOF
    exit
}

function die() {
    echo "$1"
    exit 1
}

__start_over() {
    rm -rf /tmp/NIXCFG_REPO
    umount /mnt/home
    umount /mnt/tmp
    umount /mnt
    swapoff /dev/zvol/${POOL_NAME}/SWAP/swap0
    zpool destroy ${POOL_NAME}
}

__initial_warning() {
    echo "WARNING: The following script intends to replace all of your disk(s) \
contents with a zfs-on-root NixOS installation and bootstrap your configuration.nix."

    read -p "Ready? (Y or N) " -n 1 -r
    [[ ! $REPLY =~ ^[Yy]$ ]] && die "Aborted."
}

__fail_warning() {
    read -p "The previous command failed. Continue running script? (Y or N) " -n 1 -r
    [[ ! $REPLY =~ ^[Yy]$ ]] && die "Aborted."
}

__uefi_or_legacy() {
    # TODO add uefi support.
    [ -d "/sys/firmware/efi/efivars" ] && die "Only legacy bios is supported for now."
}

__switch_if_needed() {
    nixos-rebuild switch || __fail_warning
}

__bootstrap_zfs() {
    __install_zfs() {
        sed -i '/imports/a \
boot.supportedFilesystems = [ \"zfs\" ];' \
            /etc/nixos/configuration.nix
        NEEDS_SWITCH="true"
    }
    which zfs > /dev/null 2>&1 || __install_zfs
}

__bootstrap_git() {
    __install_git() {
        sed -i '/imports/a \
 environment.systemPackages = with pkgs; [ git ];' \
            /etc/nixos/configuration.nix
        NEEDS_SWITCH="true"
    }
    which git > /dev/null 2>&1 || __install_git
}

__get_custom_nixcfg() {
    # So accomodate everyone, but github has extra features.
    # git clone the declared repo from NIXCFG_REPO ($2)
    # github users https remote will be switched to ssh remote automatically after initial clone.
    # github users also may use "shorthand" USERNAME/REPO-NAME
    # optional NIXFG_BRANCH ($3) may be used additionally for all users who need to build from a non-master branch.
    # TODO point of failure for github shorthand is reliance on "cut", should github ever change their convention. This could be better.
    GH_SHORTHAND=$(echo ${NIXCFG_REPO} | grep -v ".git")
    GITHUB_URL=$(echo ${NIXCFG_REPO} | grep "github.com")
    __checkout_branch() {
        echo "Checking out ${GITHUBSSHREMOTE}"
        cd /tmp/NIXCFG_REPO
        git checkout ${NIXCFG_BRANCH}
    }
    __switch_github_remotes() {
        echo "Switching remote from https to ${GITHUBSSHREMOTE} for user convenience..."
        cd /tmp/NIXCFG_REPO
        git remote set-url origin ${GITHUBSSHREMOTE}
    }
    __github_clone_and_switch() {
        echo "Cloning repo via ${GITHUBHTTPSREMOTE}"
        GITHUBHTTPSREMOTE=https://github.com/${GITHUB_USER}/${GITHUB_REPO}
        GITHUBSSHREMOTE=git@github.com:${GITHUB_USER}/${GITHUB_REPO}
        git clone ${GITHUBHTTPSREMOTE} /tmp/NIXCFG_REPO || __fail_warning
        __switch_github_remotes
        [[ ${NIXCFG_BRANCH} ]] && __checkout_branch
    }
    if [[ ${GITHUB_URL} ]]
    then
        GITHUB_USER=$(echo ${NIXCFG_REPO} | grep github | cut -d '/' -f 4)
        GITHUB_REPO=$(echo ${NIXCFG_REPO} | grep github | cut -d '/' -f 5)
        __github_clone_and_switch
    elif [[ ${GH_SHORTHAND} ]]
    then
        GITHUB_USER=$(echo ${NIXCFG_REPO} | cut -d '/' -f 1)
        GITHUB_REPO=$(echo ${NIXCFG_REPO} | cut -d '/' -f 2)
        __github_clone_and_switch
    else
        echo "Cloning repo via ${NIXCFG_REPO}"
        git clone ${NIXCFG_REPO} /tmp/NIXCFG_REPO || __fail_warning
        [[ ${NIXCFG_BRANCH} ]] && __checkout_branch
    fi

    # To find the users configuration.sh file:
    # First we simply use "./the/path/to/$1" if the user provides it.
    # Second if $1 has no slashes, then we search for $1 guessing it maybe a unique filename in the project.
    # Third we search again for a unique dirname, but only if the filename search turns up nothing,
    # then we append the literal "/configuration.sh" convention to the unique dirname, making assumption it must be this.
    # Finally, in all cases no matter what we use, we also need to setup optional overlay files which will be next to wherever $1 may be.
    __find_configuration_sh() {
        # If given a unique filename, use the filename to source the config variables.
        cd /tmp/NIXCFG_REPO
        find -type f -name "${NIXCFG_HOST}" | grep "." && \
            NIXCFG_HOST=$(find -type f -name "${NIXCFG_HOST}") && \
            [ ! -e "${NIXCFG_HOST}" ] && die "Error: Themelios cannot figure out which ${NIXCFG_HOST} to use. In this case, feed Themelios ./the/entire/path to the configuration.sh file you are trying to use with STARTOVER=1 POOL_NAME=$(POOL_NAME) and try again."

        # If given a unique dirname, use unique_dirname/configuration.sh convention to source the variables.
        find -type d -name "${NIXCFG_HOST}" | grep "." && \
            NIXCFG_HOST=$(echo $(find -type d -name "${NIXCFG_HOST}")/configuration.sh)
    }
    # If not given a path with slashes to a configuration.sh file, then use find.
    echo ${NIXCFG_HOST} | grep "/" || __find_configuration_sh

    source "${NIXCFG_HOST}" || die "${NIXCFG_HOST} file not found."

    # prepare optional overlay locations based on where the users configuration.sh is.
    OVERLAY_POOL=${NIXCFG_HOST%/*}/${POOL_OVERLAY_FILE}
    OVERLAY_DATASETS=${NIXCFG_HOST%/*}/${DATASETS_OVERLAY_FILE}
}

__disk_prep() {
    __sgdisk() {
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Clearing disk with sgdisk..."
            sgdisk --clear ${DISK_ID} || __fail_warning
        done
    }
    [[ ${SGDISK_CLEAR} == "true" ]] && __sgdisk

    __wipefs() {
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Wiping disk signatures with wipefs..."
            wipefs --all ${DISK_ID} || __fail_warning
        done
    }
    [[ ${WIPEFS_ALL} == "true" ]] && __wipefs

    __dd_zero() {
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Writing Zeros to each disk, this may take a while..."
            dd if=/dev/zero of=${DISK_ID} bs=4096 status=progress
        done
    }
    [[ ${ZERO_DISKS} == "true" ]] && __dd_zero

}

__zpool_create() {
    echo "Creating zpool..."
    zpool create -f \
          -o ashift=12 \
          -O compression=lz4 \
          -O atime=${ATIME:?"Please define atime."} \
          -O relatime=on \
          -O normalization=formD \
          -O xattr=sa \
          -m none \
          -R /mnt \
          ${POOL_NAME:?"Please define pool name."} \
          ${POOL_TYPE} \
          ${POOL_DISKS:?"Please define pool disks."} || __fail_warning
}

__create_bios_boot_partitions() {
    IFS=$'\n'
    for DISK_ID in ${POOL_DISKS}
    do
        echo "Creating BIOS boot partition..."
        sgdisk -a1 -n2:48:2047 -t2:EF02 -c2:"BIOS boot partition" ${DISK_ID} || __fail_warning
        partx -u ${DISK_ID}
    done
}

__datasets_create() {
    echo "Creating and mounting datasets in /mnt..."
    # / (root) datasets
    zfs create -o mountpoint=none -o canmount=off -o sync=always ${POOL_NAME}/ROOT
    zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/ROOT/nixos
    mount -t zfs ${POOL_NAME}/ROOT/nixos /mnt
    zpool set bootfs=${POOL_NAME}/ROOT/nixos ${POOL_NAME}

    __slash_nix_outside_root() {
        zfs create -o mountpoint=none -o canmount=off -o sync=always ${POOL_NAME}/NIX
        zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/NIX/nix
        mkdir /mnt/nix
        mount -t zfs ${POOL_NAME}/NIX/nix /mnt/nix
    }
    if [[ ${NIXDIR_NOROOT} == "true" ]]
    then
        __slash_nix_outside_root
    fi

    mkdir -p /mnt/{home,tmp}

    # /home datasets
    zfs create -o mountpoint=none -o canmount=off ${POOL_NAME}/HOME
    zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/HOME/home
    mount -t zfs ${POOL_NAME}/HOME/home /mnt/home

    # /tmp datasets
    zfs create -o mountpoint=none -o canmount=off ${POOL_NAME}/TMP
    zfs create -o mountpoint=legacy -o canmount=on -o sync=disabled ${POOL_NAME}/TMP/tmp
    mount -t zfs ${POOL_NAME}/TMP/tmp /mnt/tmp

    # zswap option
    if [[ ${USE_ZSWAP} == "true" ]]
    then
        echo "Creating ZSWAP volume and turning on swap..."
        zfs create \
            -o primarycache=metadata \
            -o secondarycache=metadata \
            -o compression=zle \
            -o sync=always \
            -o logbias=throughput \
            -o com.sun:auto-snapshot=false \
            ${POOL_NAME}/SWAP

        zfs create \
            -V ${ZSWAP_SIZE} \
            -b $(getconf PAGESIZE) \
            ${POOL_NAME}/SWAP/swap0

        mkswap -f /dev/zvol/${POOL_NAME}/SWAP/swap0
        swapon /dev/zvol/${POOL_NAME}/SWAP/swap0
    fi

    # TODO this is not good.
    __zfs_auto_snapshot() {
        # set com.sun:auto-snapshot properties
        if [[ ${SNAPSHOT_HOME} == "true" ]]
        then
            echo "Setting com.sun:auto-snapshot=true for HOME datasets..."
            zfs set com.sun:auto-snapshot=true ${POOL_NAME}/HOME
        elif [[ ${SNAPSHOT_ROOT} == "false" ]]
        then
            echo "Setting com.sun:auto-snapshot=false for HOME datasets..."
            zfs set com.sun:auto-snapshot=false ${POOL_NAME}/HOME
        fi

        if [[ ${SNAPSHOT_ROOT} == "true" ]]
        then
            echo "Setting com.sun:auto-snapshot=true for ROOT datasets..."
            zfs set com.sun:auto-snapshot=true ${POOL_NAME}/ROOT
        elif [[ ${SNAPSHOT_ROOT} == "false" ]]
        then
            echo "Setting com.sun:auto-snapshot=false for ROOT datasets..."
            zfs set com.sun:auto-snapshot=false ${POOL_NAME}/ROOT
        fi
    }
    __zfs_auto_snapshot
}

__bootstrap_nixcfg() {
    echo "Moving repo from /tmp to /mnt..."
    # TODO it sure would be cool to restore ownership of this repo away from root to the user owner in nix.
    cp -rp /tmp/NIXCFG_REPO /mnt/${NIXCFG_DIR}

    # This is for generating our ./hardware-configuration.nix files.
    # ./configuration.nix will be overwritten shortly hereafter.
    echo "Executing nixos-generate-config --root /mnt"
    nixos-generate-config --root /mnt || __fail_warning

    # give chance for advanced user who is hacking the script in the case of
    # installation into an already created pool to pass his already existing hostid to script. :)
    [[ ! ${POOL_HOSTID} ]] && POOL_HOSTID="random"
    __hostid_generate() {
        echo "Generating random hostid..."
        POOL_HOSTID="$(head -c4 /dev/urandom | od -A none -t x4 | cut -d ' ' -f 2)"
        echo "${POOL_HOSTID}"
    }
    [[ ${POOL_HOSTID} == "random" ]] && __hostid_generate

    # strip './' from  TLN for nix import just incase the user prefixed it with './'
    TOP_LEVEL_NIXFILE=$(echo "${TOP_LEVEL_NIXFILE}" | sed 's|^./||')

    # Create /mnt/etc/nixos/configuration.nix and import user's TOP_LEVEL_NIXFILE.
    # populate it also with networking.hostId = \"${POOL_HOSTID}\"; if user has not enabled THEMELIOS_ZFS option.
    # Otherwise, import themelios-zfs.nix for sensible general zfs settings.
    # Finally embed a heredoc inside a heredoc which contains the additional optional zfs_care options.
    if [[ ${THEMELIOS_ZFS} == "true" ]]
    then
        THEMELIOS_OPTIONAL_GENERATED="./themelios-zfs.nix"
    else
        ZFS_REQUIRED_HOSTID="networking.hostId = \"${POOL_HOSTID}\";"
    fi
    cat <<EOF > /mnt/etc/nixos/configuration.nix
{ ... }:
{ imports = [
../../${NIXCFG_DIR}/${TOP_LEVEL_NIXFILE}
./hardware-configuration.nix
${THEMELIOS_OPTIONAL_GENERATED}
];
${ZFS_REQUIRED_HOSTID}
}
EOF

    [[ ${THEMELIOS_ZFS} == "true" ]] && cat << EOF > /mnt/etc/nixos/themelios-zfs.nix
{ ... }:
{ imports = [];

# some zfs-on-root sensible settings

# configure grub using /dev/disk/by-d and zfs-support
boot.supportedFilesystems = [ "zfs" ];
boot.loader.grub.enable = true;
boot.loader.grub.version = 2;
boot.loader.grub.devices = [
$(IFS=$'\n'
for DISK_ID in ${POOL_DISKS}
do
echo $(echo "\"${DISK_ID}\"")
done)
];

# The 32-bit host ID of the machine, formatted as 8 hexadecimal characters.
# You should try to make this ID unique among your machines.
networking.hostId = "${POOL_HOSTID}";

# noop elevator recommended.
# shell_on_fail allows to force import manually in the case of zfs import failure.
boot.kernelParams = [ "elevator=noop" "boot.shell_on_fail" ];

# grub on ZFS has been known to have a hard time finding kernels with really/long/dir/paths
# Just copy the kernels to /boot and avoid the issue.
boot.loader.grub.copyKernels = true;

# Setting these to false will ensure some safeguards are active that ZFS uses to protect your ZFS pools.
boot.zfs.forceImportAll = false;
boot.zfs.forceImportRoot = false;

$([[ ${THEMELIOS_ZFS_CARE} == "true" ]] && cat <<-CARE
services.zfs.autoScrub.enable = ${care_autoScrub};
services.zfs.autoSnapshot = {
enable = ${care_autoSnapshot_enabled};
frequent = ${care_autoSnapshot_frequent};
hourly = ${care_autoSnapshot_hourly};
daily = ${care_autoSnapshot_daily};
weekly = ${care_autoSnapshot_weekly};
monthly = ${care_autoSnapshot_monthly};
};

# Use gc.automatic with zfs-auto-snapshot to keep disk space under control.
nix.gc.automatic = ${care_gc_automatic};
nix.gc.dates = "${care_gc_dates}";
nix.gc.options = "${care_gc_options}";

# clean /tmp automatically on boot
boot.cleanTmpDir = ${care_cleanTmpDir};
CARE
)
}
EOF

    # nixos-install section, give user retry option with --show-trace to have chance nix imports on another TTY. :)
    __nixos-install-show-trace() {
        nixos-install --root /mnt --show-trace || __nixos-install_fail_retry
    }
    __nixos-install_fail_retry() {
        echo "themelios hint: check /mnt/etc/nixos/configuration.nix and your other files in /mnt/${NIXCFG_DIR} before trying again."
        echo "themelios hint: make sure you are using relative path imports for all of your .nix files."
        read -p "nixos-install --root /mnt failed, retry? will add --show-trace (Y or N) " -n 1 -r
        if [[ $REPLY =~ ^[Yy]$ ]]
        then
            __nixos-install-show-trace
        else
            die "The only steps remaining after nixos-install --root /mnt should be unmounting /mnt and exporting the pool :) Good luck."
        fi
    }
    __nixos-install() {
        echo "executing nixos-install --root /mnt"
        nixos-install --root /mnt || __nixos-install_fail_retry
    }

    __nixos-install
}

__thank_you() {
    cat <<EOF
NNNNNNNN        NNNNNNNNIIIIIIIIIIXXXXXXX       XXXXXXX
N:::::::N       N::::::NI::::::::IX:::::X       X:::::X
N::::::::N      N::::::NI::::::::IX:::::X       X:::::X
N:::::::::N     N::::::NII::::::IIX::::::X     X::::::X
N::::::::::N    N::::::N  I::::I  XXX:::::X   X:::::XXX
N:::::::::::N   N::::::N  I::::I     X:::::X X:::::X
N:::::::N::::N  N::::::N  I::::I      X:::::X:::::X
N::::::N N::::N N::::::N  I::::I       X:::::::::X
N::::::N  N::::N:::::::N  I::::I       X:::::::::X
N::::::N   N:::::::::::N  I::::I      X:::::X:::::X
N::::::N    N::::::::::N  I::::I     X:::::X X:::::X
N::::::N     N:::::::::N  I::::I  XXX:::::X   X:::::XXX
N::::::N      N::::::::NII::::::IIX::::::X     X::::::X
N::::::N       N:::::::NI::::::::IX:::::X       X:::::X
N::::::N        N::::::NI::::::::IX:::::X       X:::::X
NNNNNNNN         NNNNNNNIIIIIIIIIIXXXXXXX       XXXXXXX
EOF

    __umount_export() {
        [[ ${USE_ZSWAP} == "true" ]] && swapoff /dev/zvol/${POOL_NAME}/SWAP/swap0

        echo "Unmounting /mnt"
        umount /mnt/home
        umount /mnt/tmp
        umount /mnt

        echo "Exporting ${POOL_NAME}"
        zpool export ${POOL_NAME}

        read -p "Finished. Reboot now? (Y or N) " -n 1 -r
        [[ $REPLY =~ ^[Yy]$ ]] && reboot

    }
    # Pass NOUMOUNT=1 to not unmount /mnt or export the pool after install automatically
    [[ ! ${NOUMOUNT} ]] && __umount_export

    exit
}

# Start executing code !

# rerun script with "STARTOVER=1 POOL=poolname ./themelios foo bar" to attempt a fresh start.
[[ ${STARTOVER} ]] && __start_over

[[ $1 == "-h" ]] && help
[[ $1 == "--help" ]] && help
[[ $# -lt 2 ]] && usage
[[ $# -gt 3 ]] && usage
NIXCFG_HOST=$1
NIXCFG_REPO=$2
NIXCFG_BRANCH=$3

# check for legacy or uefi bios
__uefi_or_legacy

# warn user of potential doom
__initial_warning

# install zfs if needed to the livedisk
__bootstrap_zfs

# install git if needed to the livedisk
__bootstrap_git

# reconfigure nix livedisk if needed
[[ ${NEEDS_SWITCH} == "true" ]] && __switch_if_needed

# download the machine configuration from git
__get_custom_nixcfg

# use sgdisk wipefs or dd to cleanup old disks
__disk_prep

# Create default zpool or maybe-use optional user overlay instead
if [[ -e ${OVERLAY_POOL} ]] ; then source ${OVERLAY_POOL} ; else __zpool_create ; fi

# This is where grub stage1 will be installed later.
__create_bios_boot_partitions

# Create default datasets or maybe-use optional user overlay instead
if [[ -e ${OVERLAY_DATASETS} ]] ; then source ${OVERLAY_DATASETS} ; else __datasets_create ; fi

# bootstrap the users custom nix configurations
__bootstrap_nixcfg

# may you have a Happy Hacking. :)
__thank_you
