#!/usr/bin/env bash
# Copyright 2018 Adam Schaefers sch@efers.org
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
# The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

usage() {
    cat << EOF
Usage:
        themelios configuration.sh git-remote [branch]

Example:
        themelios configuration.sh https://github.com/a-schaefers/nix-config.git master

Github users may also use a shorthand:
        themelios configuration.sh a-schaefers/nix-config

Use -h or --help for more information.
EOF
    exit
}

help() {
    cat <<EOF
Themelios - Bootstrap a zfs-on-root NixOS configuration in one command

What Themelios does:
From any NixOS live disk, Themelios will do the following in approximate order:
- Automatically installs zfs and git to the livedisk if needed.
- Clones your git repo, optionally using a non-master branch.
- Finds your configuration.sh file automatically.
- Configures a zfs-on-root system to your configuration.sh file specification including the following options:
  - Uses sgdisk and/or wipefs, or dd to clear your disks.
  - Creates a single/mirror/raidz1/raidz2/raidz3 zpool
  - Configures a zfs-on-root dataset scheme by default
  - Bootstraps your top level .nix configuration and install the rest of your operating system
- Aims to fail gracefully with continue and retry options.
- A simple script, easy to hack on.

What Themelios does not do (yet):
- Currently uefi is unsupported. (imho legacy bios with zfs BE's is more robust.)
- Configure more than one pool.
- Write zeros to more than one disk concurrently.
- Full Disk encryption (kinda just waiting for zfsonlinux to hit maturity in this area...)

What Themelios will never do:
- Mess with any of your .nix files in your repo. This means you still need to turn on some basic ZFS settings in you nix files. I recommend something like the following:
https://github.com/a-schaefers/nix-config/blob/master/modules/nixos/nixos-zfs.nix

Configuration.sh Variables:
# Themelios configuration.sh example
POOL_NAME="zroot"
POOL_TYPE="raidz1"    # May also be set to "mirror". Leave empty "" for single.

# use one disk per line here!
POOL_DISKS="/dev/sda
/dev/sdb
/dev/sdc"

SGDISK_CLEAR="true"   # Use sgdisk --clear
WIPEFS_ALL="true"     # wipefs --all
ZERO_DISKS="false"    # uses dd if=/dev/zero ...
ATIME="off"           # recommended "off" for SSD disks.
SNAPSHOT_ROOT="true"  # Sets the value of com.sun:auto-snapshot
SNAPSHOT_HOME="true"
USE_ZSWAP="false"     # Creates a swap zvol
ZSWAP_SIZE="4G"

# Your top-level configuration.nix file relative path from the project_root.
# e.g. for the file project_root/hosts/hpZ620/default.nix use the following:
TOP_LEVEL_NIXFILE="hosts/hpZ620/default.nix"

# Directory name of <git-remote> in "/" (root). Do not use slashes.
NIXCFG_DIR="nix-config"

# Setting this to true would trade-off the ability to use zfs boot environments for extra disk space.
# OTOH, if you garbage collect often, this should not be much of an issue. (Recommended false.)
NIXDIR_NOROOT="false" # mount /nix outside of the / (root) dataset.

## Debug options:
See the end of the script for details.
EOF
    exit
}

[[ $1 == "-h" ]] && help
[[ $1 == "--help" ]] && help
[[ $# -lt 2 ]] && usage
[[ $# -gt 3 ]] && usage
NIXCFG_HOST=$1
NIXCFG_REPO=$2
NIXCFG_BRANCH=$3

__initial_warning() {
    echo "WARNING: The following script intends to replace all of your disk(s) \
contents with a zfs-on-root NixOS installation and bootstrap your configuration.nix."
    read -p "Ready? (Y or N) " -n 1 -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        echo "Aborted." ; exit
    fi
}

__fail_warning() {
    read -p "The previous command failed. Continue running script? (Y or N) " -n 1 -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        echo "Aborted." ; exit
    fi
}

__uefi_or_legacy() {
    # TODO add uefi support.
    if [ -d "/sys/firmware/efi/efivars" ]; then
        exit ; echo "Only legacy bios is supported with this script for now."
    fi
}

__switch_if_needed() {
    if [[ ${NEEDS_SWITCH} == "true" ]]
    then
        nixos-rebuild switch || echo "nixos-rebuild switch from switch_if_needed failed" ; __fail_warning
        NEEDS_SWITCH="false"
    fi
}

__bootstrap_zfs() {
    __install_zfs() {
        sed -i '/imports/a \
boot.supportedFilesystems = [ \"zfs\" ];' \
            /etc/nixos/configuration.nix
        NEEDS_SWITCH="true"
    }
    which zfs > /dev/null 2>&1 || __install_zfs
}

__bootstrap_git() {
    __install_git() {
        sed -i '/imports/a \
 environment.systemPackages = with pkgs; [ git ];' \
            /etc/nixos/configuration.nix
        NEEDS_SWITCH="true"
    }
    which git > /dev/null 2>&1 || __install_git
}

__get_custom_nixcfg() {
    # git clone the declared repo from NIXCFG_REPO ($2)
    # github users https remote will be switched to ssh remote automatically after initial clone.
    # github users also may use "shorthand" USERNAME/REPO-NAME
    # optional NIXFG_BRANCH ($3) may be used additionally for users who need to build from a non-master branch.
    GH_SHORTHAND=$(echo ${NIXCFG_REPO} | grep -v ".git")
    GITHUB_URL=$(echo ${NIXCFG_REPO} | grep "github.com")
    __checkout_branch() {
        echo "Checking out ${GITHUBSSHREMOTE}"
        cd /tmp/NIXCFG_REPO
        git checkout ${NIXCFG_BRANCH}
    }
    __switch_github_remotes() {
        echo "Switching remote from https to ${GITHUBSSHREMOTE} for user convenience..."
        cd /tmp/NIXCFG_REPO
        git remote set-url origin ${GITHUBSSHREMOTE}
    }
    __github_clone_and_switch() {
        echo "Cloning repo via ${GITHUBHTTPSREMOTE}"
        GITHUBHTTPSREMOTE=https://github.com/${GITHUB_USER}/${GITHUB_REPO}
        GITHUBSSHREMOTE=git@github.com:${GITHUB_USER}/${GITHUB_REPO}
        git clone ${GITHUBHTTPSREMOTE} /tmp/NIXCFG_REPO || __fail_warning
        __switch_github_remotes
        [[ ${NIXCFG_BRANCH} ]] && __checkout_branch
    }
    if [[ ${GITHUB_URL} ]]
    then
        GITHUB_USER=$(echo ${NIXCFG_REPO} | grep github | cut -d '/' -f 4)
        GITHUB_REPO=$(echo ${NIXCFG_REPO} | grep github | cut -d '/' -f 5)
        __github_clone_and_switch
    elif [[ ${GH_SHORTHAND} ]]
    then
        GITHUB_USER=$(echo ${NIXCFG_REPO} | cut -d '/' -f 1)
        GITHUB_REPO=$(echo ${NIXCFG_REPO} | cut -d '/' -f 2)
        __github_clone_and_switch
    else
        echo "Cloning repo via ${NIXCFG_REPO}"
        git clone ${NIXCFG_REPO} /tmp/NIXCFG_REPO || __fail_warning
        [[ ${NIXCFG_BRANCH} ]] && __checkout_branch
    fi

    # find NIXCFG_HOST ($1) and source the variables
    echo "Extracting configuration variables..."
    NIXCFG_HOST=$(cd /tmp/NIXCFG_REPO && find -name "${NIXCFG_HOST}")
    source "${NIXCFG_HOST}" || __fail_warning
    cat <<EOF
${NIXCFG_HOST}
EOF
}

__disk_prep() {
    if [[ ${SGDISK_CLEAR} == "true" ]]
    then
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Clearing disk with sgdisk..."
            sgdisk --clear ${DISK_ID} || __fail_warning
        done
    fi

    if [[ ${WIPEFS_ALL} == "true" ]]
    then
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Wiping disk signatures with wipefs..."
            wipefs --all ${DISK_ID} || __fail_warning
        done
    fi

    if [[ ${ZERO_DISKS} == "true" ]]
    then
        IFS=$'\n'
        for DISK_ID in ${POOL_DISKS}
        do
            echo "Writing Zeros to each disk, this may take a while..."
            dd if=/dev/zero of=${DISK_ID} bs=4096 status=progress
        done
    fi
}

__zpool_create() {
    echo "Creating zpool..."
    zpool create -f \
          -o ashift=12 \
          -O compression=lz4 \
          -O atime=${ATIME:?"Please define atime."} \
          -O relatime=on \
          -O normalization=formD \
          -O xattr=sa \
          -m none \
          -R /mnt \
          ${POOL_NAME:?"Please define pool name."} \
          ${POOL_TYPE} \
          ${POOL_DISKS:?"Please define pool disks."} || __fail_warning

    IFS=$'\n'
    for DISK_ID in ${POOL_DISKS}
    do
        echo "Creating BIOS boot partition..."
        sgdisk -a1 -n2:48:2047 -t2:EF02 -c2:"BIOS boot partition" ${DISK_ID} || __fail_warning
        partx -u ${DISK_ID}
    done
}

__datasets_create() {
    echo "Creating and mounting datasets in /mnt..."
    # / (root) datasets
    zfs create -o mountpoint=none -o canmount=off -o sync=always ${POOL_NAME}/ROOT
    zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/ROOT/nixos
    mount -t zfs ${POOL_NAME}/ROOT/nixos /mnt
    zpool set bootfs=${POOL_NAME}/ROOT/nixos ${POOL_NAME}

    # TRADEOFF Disk space vs. Robustness. imo-- just garbage collect more often and don't use this option.
    # /nix optional dataset outside of / dataset (I don't like this idea, but set this variable if you want.)
    # Save some potential disk space at the cost of losing ZFS boot environments (less robust.)
    __slash_nix_outside_root() {
        zfs create -o mountpoint=none -o canmount=off -o sync=always ${POOL_NAME}/NIX
        zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/NIX/nix
        mkdir /mnt/nix
        mount -t zfs ${POOL_NAME}/NIX/nix /mnt/nix
    }
    if [[ ${NIXDIR_NOROOT} == "true" ]]
    then
        __slash_nix_outside_root
    fi

    mkdir -p /mnt/{home,tmp}

    # /home datasets
    zfs create -o mountpoint=none -o canmount=off ${POOL_NAME}/HOME
    zfs create -o mountpoint=legacy -o canmount=on ${POOL_NAME}/HOME/home
    mount -t zfs ${POOL_NAME}/HOME/home /mnt/home

    # /tmp datasets
    zfs create -o mountpoint=none -o canmount=off ${POOL_NAME}/TMP
    zfs create -o mountpoint=legacy -o canmount=on -o sync=disabled ${POOL_NAME}/TMP/tmp
    mount -t zfs ${POOL_NAME}/TMP/tmp /mnt/tmp

    # zswap option
    if [[ ${USE_ZSWAP} == "true" ]]
    then
        echo "Creation ZSWAP volume and turning on swap..."
        zfs create \
            -o primarycache=metadata \
            -o secondarycache=metadata \
            -o compression=zle \
            -o sync=always \
            -o logbias=throughput \
            -o com.sun:auto-snapshot=false \
            ${POOL_NAME}/SWAP

        zfs create \
            -V ${ZSWAP_SIZE} \
            -b $(getconf PAGESIZE) \
            ${POOL_NAME}/SWAP/swap0

        mkswap -f /dev/zvol/${POOL_NAME}/SWAP/swap0
        swapon /dev/zvol/${POOL_NAME}/SWAP/swap0
    fi
}

__zfs_auto_snapshot() {
    if [[ ${SNAPSHOT_HOME} == "true" ]]
    then
        echo "Setting com.sun:auto-snapshot=true for HOME datasets..."
        zfs set com.sun:auto-snapshot=true ${POOL_NAME}/HOME
    elif [[ ${SNAPSHOT_ROOT} == "false" ]]
    then
        echo "Setting com.sun:auto-snapshot=false for HOME datasets..."
        zfs set com.sun:auto-snapshot=false ${POOL_NAME}/HOME
    fi

    if [[ ${SNAPSHOT_ROOT} == "true" ]]
    then
        echo "Setting com.sun:auto-snapshot=true for ROOT datasets..."
        zfs set com.sun:auto-snapshot=true ${POOL_NAME}/ROOT
    elif [[ ${SNAPSHOT_ROOT} == "false" ]]
    then
        echo "Setting com.sun:auto-snapshot=false for ROOT datasets..."
        zfs set com.sun:auto-snapshot=false ${POOL_NAME}/ROOT
    fi
}

__bootstrap_nixcfg() {
    echo "Moving repo from /tmp to /mnt..."
    cp -rp /tmp/NIXCFG_REPO /mnt/${NIXCFG_DIR}

    echo "Executing nixos-generate-config --root /mnt"
    nixos-generate-config --root /mnt || __fail_warning

    [[ ! ${POOL_HOSTID} ]] && POOL_HOSTID="random"
    if [[ ${POOL_HOSTID} == "random" ]]
    then
        echo "Generating random hostid..."
        POOL_HOSTID="$(head -c4 /dev/urandom | od -A none -t x4 | cut -d ' ' -f 2)"
        echo "${POOL_HOSTID}"
    fi

    #sanitize TLN for import heredoc
    TOP_LEVEL_NIXFILE=$(echo "${TOP_LEVEL_NIXFILE}" | sed 's|^./||')

    # setup user's future /etc/nixos/configuration.nix file to import their custom TOP_LEVEL_NIXFILE.
    cat <<EOF > /mnt/etc/nixos/configuration.nix
{ ... }:
{ imports = [
./hardware-configuration.nix
];
networking.hostId = "${POOL_HOSTID}";
}
EOF
    sed -i "/imports/a ../../${NIXCFG_DIR}/${TOP_LEVEL_NIXFILE}" \
        /mnt/etc/nixos/configuration.nix

    # nixos-install section
    __nixos-install-show-trace-termbin() {
        nixos-install --root /mnt --show-trace || __nixos-install_fail_retry
    }
    __nixos-install_fail_retry() {
        echo "themelios hint: check /mnt/etc/nixos/configuration.nix and your other files in /mnt/${NIXCFG_DIR} before trying again."
        echo "themelios hint: make sure you are using relative path imports for all of your .nix files."
        read -p "nixos-install --root /mnt failed, retry? will add --show-trace (Y or N) " -n 1 -r
        if [[ $REPLY =~ ^[Yy]$ ]]
        then
            __nixos-install-show-trace-termbin
        else
            exit
        fi
    }
    __nixos-install() {
        echo "executing nixos-install --root /mnt"
        nixos-install --root /mnt || __nixos-install_fail_retry
    }
    if [[ ! ${NOINSTALL} ]]
    then
        __nixos-install
    fi
}

__thank_you() {
    cat <<EOF
NNNNNNNN        NNNNNNNNIIIIIIIIIIXXXXXXX       XXXXXXX
N:::::::N       N::::::NI::::::::IX:::::X       X:::::X
N::::::::N      N::::::NI::::::::IX:::::X       X:::::X
N:::::::::N     N::::::NII::::::IIX::::::X     X::::::X
N::::::::::N    N::::::N  I::::I  XXX:::::X   X:::::XXX
N:::::::::::N   N::::::N  I::::I     X:::::X X:::::X
N:::::::N::::N  N::::::N  I::::I      X:::::X:::::X
N::::::N N::::N N::::::N  I::::I       X:::::::::X
N::::::N  N::::N:::::::N  I::::I       X:::::::::X
N::::::N   N:::::::::::N  I::::I      X:::::X:::::X
N::::::N    N::::::::::N  I::::I     X:::::X X:::::X
N::::::N     N:::::::::N  I::::I  XXX:::::X   X:::::XXX
N::::::N      N::::::::NII::::::IIX::::::X     X::::::X
N::::::N       N:::::::NI::::::::IX:::::X       X:::::X
N::::::N        N::::::NI::::::::IX:::::X       X:::::X
NNNNNNNN         NNNNNNNIIIIIIIIIIXXXXXXX       XXXXXXX
EOF

    __umount_mnt() {
        if [[ ${USE_ZSWAP} == "true" ]]
        then
            swapoff /dev/zvol/${POOL_NAME}/SWAP/swap0
        fi
        echo "Unmounting /mnt"
        umount /mnt/home
        umount /mnt/tmp
        umount /mnt
    }
    [[ ! ${NOUMOUNT} ]] && __umount_mnt
    [[ ! ${NOINSTALL} ]] && zpool export ${POOL_NAME}

    read -p "Finished. Reboot now? (Y or N) " -n 1 -r
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
        reboot
    fi

    exit
}

# debug section

# Pass NOUMOUNT=1 to not unmount /mnt automatically
# Pass NOINSTALL=1 to skip nixos-install command
# run "STARTOVER=1 POOL=poolname ./themelios foo bar" to rerun the script with a fresh start.
__start_over() {
    umount /mnt/home
    umount /mnt/tmp
    umount /mnt
    rm -rf /tmp/NIXCFG_REPO
    zpool destroy ${POOL}
}
[[ ${STARTOVER} ]] && __start_over

# add exits as necessary here

__uefi_or_legacy       # check for legacy or uefi bios
__initial_warning      # warn user of potential doom
__bootstrap_zfs        # install zfs if needed to the livedisk
__bootstrap_git        # install git if needed to the livedisk
__switch_if_needed     # reconfigure nix livedisk if needed
__get_custom_nixcfg    # download the machine configuration from git
__disk_prep            # use sgdisk wipefs or dd to cleanup old disks
__zpool_create         # create the zpool, make gpt bios boot partition
__datasets_create      # create a zfs dataset layout
__zfs_auto_snapshot    # set com.sun:auto-snapshot properties
__bootstrap_nixcfg     # bootstrap the users custom nix configurations
__thank_you            # may you have a Happy Hacking. :)
